import{$ as R,a0 as y,l as _,a1 as L,a2 as j,x as T,a3 as E,Q as H,A as x,a4 as S,a5 as M,a6 as N,i as P,s as V,e as k,o as z,J as $,d as g,u as I,a7 as K,c as F,a as J,a8 as h,a9 as Q,aa as U,ab as q,ac as G,v as D,N as W,ad as X,n as Y,ae as Z,af as A}from"./Cr-UwMNL.js";const ee=e=>e==="defer"||e===!1;function ue(...e){var O;const n=typeof e[e.length-1]=="string"?e.pop():void 0;typeof e[0]!="string"&&e.unshift(n);let[t,l,a={}]=e;if(typeof t!="string")throw new TypeError("[nuxt] [asyncData] key must be a string.");if(typeof l!="function")throw new TypeError("[nuxt] [asyncData] handler must be a function.");const s=R(),m=l,p=()=>y.value,c=()=>s.isHydrating?s.payload.data[t]:s.static.data[t];a.server=a.server??!0,a.default=a.default??p,a.getCachedData=a.getCachedData??c,a.lazy=a.lazy??!1,a.immediate=a.immediate??!0,a.deep=a.deep??y.deep,a.dedupe=a.dedupe??"cancel";const d=a.getCachedData(t,s),b=d!=null;if(!s._asyncData[t]||!a.immediate){(O=s.payload._errors)[t]??(O[t]=y.errorValue);const i=a.deep?_:L;s._asyncData[t]={data:i(b?d:a.default()),pending:_(!b),error:j(s.payload._errors,t),status:_("idle"),_default:a.default}}const r={...s._asyncData[t]};delete r._default,r.refresh=r.execute=(i={})=>{if(s._asyncDataPromises[t]){if(ee(i.dedupe??a.dedupe))return s._asyncDataPromises[t];s._asyncDataPromises[t].cancelled=!0}if(i._initial||s.isHydrating&&i._initial!==!1){const u=i._initial?d:a.getCachedData(t,s);if(u!=null)return Promise.resolve(u)}r.pending.value=!0,r.status.value="pending";const f=new Promise((u,o)=>{try{u(m(s))}catch(v){o(v)}}).then(async u=>{if(f.cancelled)return s._asyncDataPromises[t];let o=u;a.transform&&(o=await a.transform(u)),a.pick&&(o=te(o,a.pick)),s.payload.data[t]=o,r.data.value=o,r.error.value=y.errorValue,r.status.value="success"}).catch(u=>{if(f.cancelled)return s._asyncDataPromises[t];r.error.value=N(u),r.data.value=P(a.default()),r.status.value="error"}).finally(()=>{f.cancelled||(r.pending.value=!1,delete s._asyncDataPromises[t])});return s._asyncDataPromises[t]=f,s._asyncDataPromises[t]},r.clear=()=>ae(s,t);const C=()=>r.refresh({_initial:!0}),w=a.server!==!1&&s.payload.serverRendered;{const i=T();if(i&&w&&a.immediate&&!i.sp&&(i.sp=[]),i&&!i._nuxtOnBeforeMountCbs){i._nuxtOnBeforeMountCbs=[];const o=i._nuxtOnBeforeMountCbs;E(()=>{o.forEach(v=>{v()}),o.splice(0,o.length)}),H(()=>o.splice(0,o.length))}w&&s.isHydrating&&(r.error.value||d!=null)?(r.pending.value=!1,r.status.value=r.error.value?"error":"success"):i&&(s.payload.serverRendered&&s.isHydrating||a.lazy)&&a.immediate?i._nuxtOnBeforeMountCbs.push(C):a.immediate&&C();const f=M();if(a.watch){const o=x(a.watch,()=>r.refresh());f&&S(o)}const u=s.hook("app:data:refresh",async o=>{(!o||o.includes(t))&&await r.refresh()});f&&S(u)}const B=Promise.resolve(s._asyncDataPromises[t]).then(()=>r);return Object.assign(B,r),B}function ae(e,n){n in e.payload.data&&(e.payload.data[n]=void 0),n in e.payload._errors&&(e.payload._errors[n]=y.errorValue),e._asyncData[n]&&(e._asyncData[n].data.value=void 0,e._asyncData[n].error.value=y.errorValue,e._asyncData[n].pending.value=!1,e._asyncData[n].status.value="idle"),n in e._asyncDataPromises&&(e._asyncDataPromises[n]&&(e._asyncDataPromises[n].cancelled=!0),e._asyncDataPromises[n]=void 0)}function te(e,n){const t={};for(const l of n)t[l]=e[l];return t}const se={},ne={class:"font-medium pb-2 text-lg"};function re(e,n){return z(),k("p",ne,[$(e.$slots,"default")])}const ce=V(se,[["render",re]]),oe=g({name:"LayoutLoader",inheritAttrs:!1,props:{name:String,layoutProps:Object},setup(e,n){return()=>D(h[e.name],e.layoutProps,n.slots)}}),de=g({name:"NuxtLayout",inheritAttrs:!1,props:{name:{type:[String,Boolean,Object],default:null},fallback:{type:[String,Object],default:null}},setup(e,n){const t=R(),l=Q(G),a=l===I()?K():l,s=F(()=>{let c=P(e.name)??a.meta.layout??"default";return c&&!(c in h)&&e.fallback&&(c=P(e.fallback)),c}),m=_();n.expose({layoutRef:m});const p=t.deferHydration();if(t.isHydrating){const c=t.hooks.hookOnce("app:error",p);J().beforeEach(c)}return()=>{const c=s.value&&s.value in h,d=a.meta.layoutTransition??U;return q(c&&d,{default:()=>D(X,{suspensible:!0,onResolve:()=>{W(p)}},{default:()=>D(ie,{layoutProps:Y(n.attrs,{ref:m}),key:s.value||void 0,name:s.value,shouldProvide:!e.name,hasTransition:!!d},n.slots)})}).default()}}}),ie=g({name:"NuxtLayoutProvider",inheritAttrs:!1,props:{name:{type:[String,Boolean]},layoutProps:{type:Object},hasTransition:{type:Boolean},shouldProvide:{type:Boolean}},setup(e,n){const t=e.name;return e.shouldProvide&&Z(A,{isCurrent:l=>t===(l.meta.layout??"default")}),()=>{var l,a;return!t||typeof t=="string"&&!(t in h)?(a=(l=n.slots).default)==null?void 0:a.call(l):D(oe,{key:t,layoutProps:e.layoutProps,name:t},n.slots)}}});export{de as _,ce as a,ue as u};
