import{A as B,a4 as y,y as p,a5 as L,a6 as R,M as T,a7 as M,a8 as x,X as E,a2 as w,a1 as H,a9 as z,x as g,_ as N,c as V,o as k,f as I,d as P,R as K,aa as $,l as F,S as U,ab as h,ac as X,ad as q,ae as G,af as J,L as D,ag as Q,ah as W,C as Y,ai as Z,aj as A}from"./C_-Ao5nl.js";const ee=e=>e==="defer"||e===!1;function de(...e){var j;const n=typeof e[e.length-1]=="string"?e.pop():void 0;typeof e[0]!="string"&&e.unshift(n);let[t,l,a={}]=e;if(typeof t!="string")throw new TypeError("[nuxt] [asyncData] key must be a string.");if(typeof l!="function")throw new TypeError("[nuxt] [asyncData] handler must be a function.");const s=B(),m=l,_=()=>y.value,c=()=>s.isHydrating?s.payload.data[t]:s.static.data[t];a.server=a.server??!0,a.default=a.default??_,a.getCachedData=a.getCachedData??c,a.lazy=a.lazy??!1,a.immediate=a.immediate??!0,a.deep=a.deep??y.deep,a.dedupe=a.dedupe??"cancel";const d=a.getCachedData(t,s),b=d!=null;if(!s._asyncData[t]||!a.immediate){(j=s.payload._errors)[t]??(j[t]=y.errorValue);const i=a.deep?p:L;s._asyncData[t]={data:i(b?d:a.default()),pending:p(!b),error:R(s.payload._errors,t),status:p("idle"),_default:a.default}}const r={...s._asyncData[t]};delete r._default,r.refresh=r.execute=(i={})=>{if(s._asyncDataPromises[t]){if(ee(i.dedupe??a.dedupe))return s._asyncDataPromises[t];s._asyncDataPromises[t].cancelled=!0}if(i._initial||s.isHydrating&&i._initial!==!1){const u=i._initial?d:a.getCachedData(t,s);if(u!=null)return Promise.resolve(u)}r.pending.value=!0,r.status.value="pending";const f=new Promise((u,o)=>{try{u(m(s))}catch(v){o(v)}}).then(async u=>{if(f.cancelled)return s._asyncDataPromises[t];let o=u;a.transform&&(o=await a.transform(u)),a.pick&&(o=te(o,a.pick)),s.payload.data[t]=o,r.data.value=o,r.error.value=y.errorValue,r.status.value="success"}).catch(u=>{if(f.cancelled)return s._asyncDataPromises[t];r.error.value=z(u),r.data.value=g(a.default()),r.status.value="error"}).finally(()=>{f.cancelled||(r.pending.value=!1,delete s._asyncDataPromises[t])});return s._asyncDataPromises[t]=f,s._asyncDataPromises[t]},r.clear=()=>ae(s,t);const S=()=>r.refresh({_initial:!0}),C=a.server!==!1&&s.payload.serverRendered;{const i=T();if(i&&C&&a.immediate&&!i.sp&&(i.sp=[]),i&&!i._nuxtOnBeforeMountCbs){i._nuxtOnBeforeMountCbs=[];const o=i._nuxtOnBeforeMountCbs;M(()=>{o.forEach(v=>{v()}),o.splice(0,o.length)}),x(()=>o.splice(0,o.length))}C&&s.isHydrating&&(r.error.value||d!=null)?(r.pending.value=!1,r.status.value=r.error.value?"error":"success"):i&&(s.payload.serverRendered&&s.isHydrating||a.lazy)&&a.immediate?i._nuxtOnBeforeMountCbs.push(S):a.immediate&&S();const f=H();if(a.watch){const o=E(a.watch,()=>r.refresh());f&&w(o)}const u=s.hook("app:data:refresh",async o=>{(!o||o.includes(t))&&await r.refresh()});f&&w(u)}const O=Promise.resolve(s._asyncDataPromises[t]).then(()=>r);return Object.assign(O,r),O}function ae(e,n){n in e.payload.data&&(e.payload.data[n]=void 0),n in e.payload._errors&&(e.payload._errors[n]=y.errorValue),e._asyncData[n]&&(e._asyncData[n].data.value=void 0,e._asyncData[n].error.value=y.errorValue,e._asyncData[n].pending.value=!1,e._asyncData[n].status.value="idle"),n in e._asyncDataPromises&&(e._asyncDataPromises[n]&&(e._asyncDataPromises[n].cancelled=!0),e._asyncDataPromises[n]=void 0)}function te(e,n){const t={};for(const l of n)t[l]=e[l];return t}const se={},ne={class:"font-medium pb-2 text-lg"};function re(e,n){return k(),V("p",ne,[I(e.$slots,"default")])}const oe=N(se,[["render",re]]),fe=Object.freeze(Object.defineProperty({__proto__:null,default:oe},Symbol.toStringTag,{value:"Module"})),ie=P({name:"LayoutLoader",inheritAttrs:!1,props:{name:String,layoutProps:Object},setup(e,n){return()=>D(h[e.name],e.layoutProps,n.slots)}}),le=P({name:"NuxtLayout",inheritAttrs:!1,props:{name:{type:[String,Boolean,Object],default:null},fallback:{type:[String,Object],default:null}},setup(e,n){const t=B(),l=X(J),a=l===K()?$():l,s=F(()=>{let c=g(e.name)??a.meta.layout??"default";return c&&!(c in h)&&e.fallback&&(c=g(e.fallback)),c}),m=p();n.expose({layoutRef:m});const _=t.deferHydration();if(t.isHydrating){const c=t.hooks.hookOnce("app:error",_);U().beforeEach(c)}return()=>{const c=s.value&&s.value in h,d=a.meta.layoutTransition??q;return G(c&&d,{default:()=>D(W,{suspensible:!0,onResolve:()=>{Q(_)}},{default:()=>D(ue,{layoutProps:Y(n.attrs,{ref:m}),key:s.value||void 0,name:s.value,shouldProvide:!e.name,hasTransition:!!d},n.slots)})}).default()}}}),ue=P({name:"NuxtLayoutProvider",inheritAttrs:!1,props:{name:{type:[String,Boolean]},layoutProps:{type:Object},hasTransition:{type:Boolean},shouldProvide:{type:Boolean}},setup(e,n){const t=e.name;return e.shouldProvide&&Z(A,{isCurrent:l=>t===(l.meta.layout??"default")}),()=>{var l,a;return!t||typeof t=="string"&&!(t in h)?(a=(l=n.slots).default)==null?void 0:a.call(l):D(ie,{key:t,layoutProps:e.layoutProps,name:t},n.slots)}}}),ye=Object.freeze(Object.defineProperty({__proto__:null,default:le},Symbol.toStringTag,{value:"Module"}));export{fe as S,le as _,oe as a,ye as n,de as u};
